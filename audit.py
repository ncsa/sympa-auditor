# audit.py
from selenium import webdriver
import time
from selenium.webdriver.common.by import By
import json
import argparse
import os
from collections import defaultdict
import ldap3
import yaml

# GLOBAL VARIABLES
MAILING_LIST_URL = ''
OUTPUT_FILE = ''
USER_AGENT = '' 
USE_CASE_PATH = ''
WEB_UI_PAGES = None
GROUP = 'all_ncsa_employe'
LDAP_HOST = 'ldap1.ncsa.illinois.edu'

def get_email_list_from_ldap(group_name, ldap_host):
    """
    Retrieves the email list of the members in group_name using ldap server
    
    Args:
        group_name (str): The name of the specified group
    
    Returns:
        A list of emails from the specified group_name using ldap server
    """
    # ldap_server = f"ldaps://ldap1.ncsa.illinois.edu"  # Replace with your LDAP server
    ldap_server = f"ldaps://{ldap_host}"
    ldap_user = None
    ldap_password = None

    search_base = 'dc=ncsa,dc=illinois,dc=edu'
    
    search_scope = ldap3.SUBTREE
    attributes = ldap3.ALL_ATTRIBUTES

    group_list = [
        group_name
    ]

    with ldap3.Connection(ldap_server, ldap_user, ldap_password) as conn:
        emails = set()
        
        if not conn.bind():
            raise Exception("Error: Could not bind to LDAP server")
        
        for group_name in group_list:
            search_filter = f"(cn={group_name})"
            result = conn.search(search_base, search_filter, search_scope, attributes=attributes)
            if not result:
                raise KeyError(f"Error: Could not find group {group_name}")
            else:
                members = [ m.split(',')[0].split('=')[1] for m in conn.entries[0].uniqueMember ]

        for member in members:    
        
            result = conn.search(search_base, f"(uid={member})", search_scope, attributes=attributes)
            if not result:
                raise KeyError(f"Error: Could not find member with uid {member}")
            else:
                emails.add(str(conn.entries[0].mail))
                    
        return emails

def check_ncsa_affiliated(user_emails: list[str], ncsa_employee_emails: set[str]):
    """
    Check which users from user_emails are ncsa affiliated
    
    Args:
        user_emails (list[str]): A list of user emails
        ncsa_employee_emails (set[str]): A list of ncsa employees' emails. 
    
    Returns:
        list[str]: A list of ncsa affilicated emails from user_emails
    """
    
    res = []
    for email in user_emails:
        if email in ncsa_employee_emails:
            res.append(email)
    return res
    
def connect_with_session(sympa_session: str) -> webdriver.Remote:
    """
    Creates a selenium session with MAILING_LIST_URL using the sympa_session token.

    Args:
        sympa_session (str): Session token generated by logging into MAILING_LIST_URL

    Returns:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
    """

    options = webdriver.ChromeOptions()
    options.add_argument("--headless")  # Run in headless mode
    options.add_argument(f"--user-agent={USER_AGENT}")
    
    driver = webdriver.Remote(
        command_executor='http://selenium:4444/wd/hub',  # Selenium host & port
        options=options
    )

    driver.get(MAILING_LIST_URL)
    
    driver.delete_all_cookies()

    domain = MAILING_LIST_URL
    if "https://" in domain:
        domain = domain[8:] # https
    else:
        domain = domain[7:] # http

    cookies = [{
        'domain': domain,
        'httpOnly': True,
        'name': 'sympa_session',
        'path': '/',
        'sameSite': 'Lax',
        'secure': True,
        'value': sympa_session
    }]

    for cookie in cookies:
        copy_cookie = cookie.copy()
        try:
            driver.add_cookie(copy_cookie)
        except Exception as e:
            print(f"Error adding cookie: {cookie['name']} - {e}")
    return driver

def get_list_names(driver: webdriver.Remote) -> list[str]:
    """
    Retrieves all mailing lists from MAILING_LIST_URL.

    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 

    Returns:
        res (list[str]): Returns a list consisting of the mailing list names from MAILING_LIST_URL
    """

    res = list()
    url = f"{MAILING_LIST_URL}/lists/lists"
    driver.get(url)

    element = driver.find_elements('css selector', 'li.listenum > a')
    for item in element:
        res.append(item.text)

    if len(res) != 0:
        print("Success")

    return res
    
def get_select_option(driver: webdriver.Remote, list_name: str, page: str) -> dict[str:str]:
    """
    Given a specific page, retrieve the listed parameters in WEB_UI_PAGES. This function can only retrieve 
    elements with an id that starts with param. 
    
    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        list_name (str): The name of the mailing list (without the @lists.ncsa.illinois.edu)
        page (str): The page's title on the webUI (list_definition, sending_receiving_setup, etc)

    Returns:
        dict[str:str]: A dictionary of the parameters and its values from page.
    """
    
    configs = dict()
    endpoint = WEB_UI_PAGES[page]["endpoint"]
    ids = WEB_UI_PAGES[page]["ids"]
    
    url = f"{MAILING_LIST_URL}{endpoint[0]}{list_name}{endpoint[1]}"
    driver.get(url)
    
    time.sleep(1)

    for id in ids:
        select_element = driver.find_element(By.ID, id)
        res = select_element.get_attribute("value")
        if len(res) == 0:
            res = "default"
        configs[id] = res
    return configs

def get_miscellaneous(driver: webdriver.Remote, list_name: str) -> dict[str:str]:
    """
    Retrieve the creator, creator_date, modifier, last_update, and status parameters in WEB_UI_PAGES for the miscellaneous page. 
    
    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        list_name (str): The name of the mailing list (without the @lists.ncsa.illinois.edu)
        option (str): One of allowed_sender_list, blocked_sender_list, and moderated_sender_list

    Returns:
        dict[str:str]: A dictionary of the parameters and its values from the miscellaneous page.
    """
    
    endpoint = WEB_UI_PAGES['miscellaneous']['endpoint']
    url = f"{MAILING_LIST_URL}{endpoint[0]}{list_name}{endpoint[1]}"
    driver.get(url)
    
    time.sleep(1)
    res = dict()
    
    select_element = driver.find_element(By.ID, "item.creation")
    text = select_element.text.split('\n')
    res["creator"] = text[1]
    res["creation_date"] = text[3]
    
    select_element = driver.find_element(By.ID, "item.update")
    text = select_element.text.split('\n')
    res["modifier"] = text[1]
    res["last_update"] = text[3]
    
    select_element = driver.find_element(By.ID, "item.status")
    res["status"] = select_element.text
    
    return res

def get_sender_lists(driver: webdriver.Remote, list_name: str, option: str):
    """
    Retrieves the listed emails in Allowed Sender, Blocked Sender, or Moderated Sender list. 
    
    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        list_name (str): The name of the mailing list (without the @lists.ncsa.illinois.edu).
        option (str): One of allowed_sender_list, blocked_sender_list, and moderated_sender_list.

    Returns:
        list[str]: A list of user emails
    """
    
    endpoint = WEB_UI_PAGES[option]
    url = f"{MAILING_LIST_URL}{endpoint}{list_name}"
    driver.get(url)
    time.sleep(1)
    select_element = driver.find_element(By.TAG_NAME, "textarea")
    return select_element.text.split('\n')

def get_list_owners(driver: webdriver.Remote, list_name: str) -> list[str]:
    """
    Retrieves the emails of the owners of the mailing list.
    
    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        list_name (str): The name of the mailing list (without the @lists.ncsa.illinois.edu).

    Returns:
        list[str]: A list of owner user emails.
    """
    
    # url = f"https://lists.ncsa.illinois.edu/lists/review/{list_name}/owner"
    endpoint = WEB_UI_PAGES['users_owners']
    url = f"{MAILING_LIST_URL}{endpoint[0]}{list_name}{endpoint[1]}"
    
    driver.get(url)
    time.sleep(1)
    select_element = driver.find_elements("xpath", "//*[starts-with(@id, 'item.owner.')]")
    
    owners = []
    for entry in select_element[:len(select_element) - 1]:
        user_entry = entry.text.split('\n')
        owners.append(user_entry[0]) # Should be the email
    return owners

def get_list_editors(driver: webdriver.Remote, list_name: str) -> list[str]:
    """
    Retrieves the emails of the editors/moderators of the mailing list.
    
    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        list_name (str): The name of the mailing list (without the @lists.ncsa.illinois.edu).

    Returns:
        list[str]: A list of moderators/editors user emails.
    """
    
    # url = f"https://lists.ncsa.illinois.edu/lists/review/{list_name}/editor"
    endpoint = WEB_UI_PAGES['users_editors']
    url = f"{MAILING_LIST_URL}{endpoint[0]}{list_name}{endpoint[1]}"
    
    driver.get(url)
    time.sleep(1)
    editors = []
    select_element = driver.find_elements("xpath", "//*[starts-with(@id, 'item.editor.')]")
    for entry in select_element[:len(select_element) - 1]:
        user_entry = entry.text.split('\n')
        editors.append(user_entry[0]) # Should be the email
    return editors
        
def get_non_use_case_matches(mailing_lists: list[dict[str:str]]) -> list[dict[str:str]]:
    """
    Finds the mailing lists that dont' match to any of the pre-defined use cases. 

    Args:
        mailing_lists (list[dict[str:str]]): A list of mailing list entries represented as dictionaries. 

    Returns:
        non_matches (list[dict[str:str]]): A list of mailing list entries represented as dictionaries that don't match any use cases. 
    """

    if mailing_lists is None:
        raise ValueError("mailing_lists cannot be None")

    if not USE_CASE_PATH:
        raise ValueError("The USE_CASE_PATH environment variable must be specified")

    use_cases_as_dict = dict()
    use_cases_as_set = set()
    non_matches = list()

    with open(USE_CASE_PATH, 'r') as f:
        use_cases_as_dict = json.load(f)
    
    for configs in use_cases_as_dict.values():
        use_cases_as_set.add(frozenset(configs.items()))

    for mailing_list in mailing_lists:
        tmp_mailing_list = dict(mailing_list)
        tmp_mailing_list.pop('list_name')

        if frozenset(tmp_mailing_list.items()) not in use_cases_as_set:
            # List doesn't match any use case
            non_matches.append(mailing_list)

    return non_matches

def categorize_data(mailing_lists: list[dict[str:str]]) -> defaultdict[str:defaultdict[str:list[str]]]:
    """
    Categorize each mailing list into its respective selection for each option.

    Args:
        mailing_lists (list[dict[str:str]]): A list of mailing list entries represented as dictionaries. 

    Returns:
        res (defaultdict[str:defaultdict[str:list(str)]]): Categorize the different configurations and index each mailing list into their respective configuration
    """

    if mailing_lists is None:
        raise ValueError("mailing_lists cannot be None")

    res = defaultdict(lambda: defaultdict(list))
    for mailing_list in mailing_lists:
        for option, selection in mailing_list.items():
            if option == 'list_name': continue
            res[option][selection].append(mailing_list['list_name'])
    return res

def dump_to_file(output: object) -> None:
    if output is None:
        raise ValueError("output cannot be None")

    with open(OUTPUT_FILE, "w") as f:
        json.dump(output, f, indent=2)

def dump_to_console(output: object) -> None:
    if output is None:
        raise ValueError("output cannot be None")
    print(json.dumps(output))

def parse_args():
    parser = argparse.ArgumentParser(description="Get symmpa_session")
    parser.add_argument("-s", "--sympa_session", type=str, default='', help="sympa_session cookie for logged in session. Outputs a file with list names and their configurations")
    parser.add_argument("-c", "--console", action='store_true', help="Dump list metatdata to console")
    args = parser.parse_args()
    return args

def main():
    # Get the user arguments
    args = parse_args()
    
    # Start the selenium session
    driver = connect_with_session(args.sympa_session)

    # Get all lists
    list_names = get_list_names(driver)
    
    # Retrieve emails of ncsa employees
    ncsa_employee_emails = get_email_list_from_ldap(GROUP, LDAP_HOST)
    
    # Contains mailing list entries
    list_configs = dict()
     
    for list_name in list_names:
        list_name = list_name.split('@')[0]
        list_configs[list_name] = dict()
        for page in WEB_UI_PAGES:
            if not isinstance(WEB_UI_PAGES[page], dict):
                continue
            list_configs[list_name][page] = get_select_option(driver, list_name, page)
        
        # Edit List Config -> Miscellaneous
        list_configs[list_name]["miscellaneous"].update(get_miscellaneous(driver, list_name))
        
        list_configs[list_name]["sender_lists"] = dict()
        
        # Sender Lists -> Allowed Senders
        list_configs[list_name]["sender_lists"]["allowed_sender"] = get_sender_lists(driver, list_name, "allowed_sender_list")
        
        # Sender Lists -> Blocked Senders
        list_configs[list_name]["sender_lists"]["blocked_sender"] = get_sender_lists(driver, list_name, "blocked_sender_list")
        
        # Sender Lists -> Moderated Senders
        list_configs[list_name]["sender_lists"]["moderated_sender"] = get_sender_lists(driver, list_name, "moderated_sender_list")
        
        # Users -> Owners
        list_owners =  get_list_owners(driver, list_name)
        list_configs[list_name]["owners"] = list_owners
        list_configs[list_name]["ncsa_owners"] = check_ncsa_affiliated(list_owners, ncsa_employee_emails)
        
        # Users -> Editors
        list_editors = get_list_editors(driver, list_name)
        list_configs[list_name]["editors"] = list_editors
        list_configs[list_name]["ncsa_editors"] = check_ncsa_affiliated(list_editors, ncsa_employee_emails)
            
    # Ends the selenium session
    driver.quit()
    
    if args.console:
        dump_to_console(list_configs)
    else:
        dump_to_file(list_configs)

if __name__ == '__main__':
    # Loading in Environment variables 
    MAILING_LIST_URL = os.getenv('MAILING_LIST_URL')
    OUTPUT_FILE = os.getenv('OUTPUT_FILE')
    USER_AGENT = os.getenv('USER_AGENT')
    CONFIG_PATH = os.getenv('CONFIG_PATH')
    
    # Read a YAML file and convert it to a Python dictionary
    with open('config.yaml', 'r') as file:
        WEB_UI_PAGES = yaml.safe_load(file)

    print('start auditing')
    main()