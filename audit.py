# audit.py
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import pickle
import time
from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.by import By
from dataclasses import dataclass, asdict
import json
from pathlib import Path
import argparse
import os
from collections import defaultdict

# GLOBAL VARIABLES
MAILING_LIST_URL = ''
OUTPUT_FILE = ''
USER_AGENT = '' 
USE_CASE_PATH = ''

def connect_with_session(sympa_session: str) -> webdriver.Remote:
    """
    Creates a selenium session with MAILING_LIST_URL using the sympa_session token.

    Args:
        sympa_session (str): Session token generated by logging into MAILING_LIST_URL

    Returns:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
    """

    options = webdriver.ChromeOptions()
    options.add_argument("--headless")  # Run in headless mode
    options.add_argument(f"--user-agent={USER_AGENT}")
    
    driver = webdriver.Remote(
        command_executor='http://selenium:4444/wd/hub',  # Selenium host & port
        options=options
    )

    driver.get(MAILING_LIST_URL)
    
    driver.delete_all_cookies()

    domain = MAILING_LIST_URL
    if "https://" in domain:
        domain = domain[8:] # https
    else:
        domain = domain[7:] # http

    cookies = [{
        'domain': domain,
        'httpOnly': True,
        'name': 'sympa_session',
        'path': '/',
        'sameSite': 'Lax',
        'secure': True,
        'value': sympa_session
    }]

    for cookie in cookies:
        copy_cookie = cookie.copy()
        try:
            driver.add_cookie(copy_cookie)
        except Exception as e:
            print(f"Error adding cookie: {cookie['name']} - {e}")
    return driver

def get_list_names(driver: webdriver.Remote) -> list[str]:
    """
    Retrieves all mailing lists from MAILING_LIST_URL.

    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 

    Returns:
        res (list[str]): Returns a list consisting of the mailing list names from MAILING_LIST_URL
    """

    res = list()
    url = f"{MAILING_LIST_URL}/lists/lists"
    driver.get(url)

    element = driver.find_elements('css selector', 'li.listenum > a')
    for item in element:
        res.append(item.text)

    if len(res) != 0:
        print("Success")

    return res
    
def get_list_option(driver: webdriver.Remote, option: str) -> str:
    """
    Retrieves the specific selection for the given option (info, add, subscribe, unsubscribe, del, invite, remind, review).

    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        option (str): info, add, subscribe, unsubscribe, del, invite, remind, review.

    Returns:
        str: The selected choice for the given option. 
    """

    selection = f"param.{option}"
    select_element = driver.find_element(By.ID, selection)

    select = Select(select_element)

    # Get the currently selected option
    selected_option = select.first_selected_option
    return selected_option.get_attribute("value")

def get_list_configuration(driver: webdriver.Remote, list_name: str) -> dict[str, str]:
    """
    Args:
        driver (webdriver.Remote): The remote WebDriver instance from connecting to the running Selenium server. 
        list_name (str): The name of the mailing list (including domain ex. abc@lists.ncsa.illinois.edu).

    Returns:
        list_configuration (dict[str, str]): A list of configurations for the mailing list.
    """

    list_name = list_name.split('@')[0]
    url = f"{MAILING_LIST_URL}/lists/edit_list_request/{list_name}/command"
    driver.get(url)

    time.sleep(1)
    
    list_configuration = {
        "list_name": list_name,
        "info": get_list_option(driver, 'info'),
        "add": get_list_option(driver, 'add'),
        "subscribe": get_list_option(driver, 'subscribe'),
        "unsubscribe": get_list_option(driver, 'unsubscribe'),
        "delete": get_list_option(driver, 'del'),
        "invite": get_list_option(driver, 'invite'),
        "remind": get_list_option(driver, 'remind'),
        "review": get_list_option(driver, 'review'),
    }
    return list_configuration

def get_non_use_case_matches(mailing_lists: list[dict[str:str]]) -> list[dict[str:str]]:

    """
    Finds the mailing lists that dont' match to any of the pre-defined use cases. 

    Args:
        mailing_lists (list[dict[str:str]]): A list of mailing list entries represented as dictionaries. 

    Returns:
        non_matches (list[dict[str:str]]): A list of mailing list entries represented as dictionaries that don't match any use cases. 
    """

    if mailing_lists is None:
        raise ValueError("mailing_lists cannot be None")

    if not USE_CASE_PATH:
        raise ValueError("The USE_CASE_PATH environment variable must be specified")

    use_cases_as_dict = dict()
    use_cases_as_set = set()
    non_matches = list()

    with open(USE_CASE_PATH, 'r') as f:
        use_cases_as_dict = json.load(f)
    
    for configs in use_cases_as_dict.values():
        use_cases_as_set.add(frozenset(configs.items()))

    for mailing_list in mailing_lists:
        tmp_mailing_list = dict(mailing_list)
        tmp_mailing_list.pop('list_name')

        if frozenset(tmp_mailing_list.items()) not in use_cases_as_set:
            # List doesn't match any use case
            non_matches.append(mailing_list)

    return non_matches

def dump_to_file(output: object) -> None:
    if output is None:
        raise ValueError("output cannot be None")

    with open(OUTPUT_FILE, "w") as f:
        json.dump(output, f, indent=2)

def dump_to_console(output: object) -> None:
    if output is None:
        raise ValueError("output cannot be None")
    print(json.dumps(output))

def transform_mailing_lists_to_dict(mailing_lists: list[dict[str:str]]) -> dict[str:dict[str:str]]:
    """
    Transforms mailing_list into a dictionary with list_name as the key

    Args:
        mailing_lists (list[dict[str:str]]): A list of mailing list entries represented as dictionaries. 

    Returns:
        res (dict[str:dict[str:str]]): A dictionary of mailing list entries represented as dictionaries. 
    """

    if mailing_lists is None:
        raise ValueError("mailing_lists cannot be None")

    res = dict()
    for mailing_list in mailing_lists:
        list_name = mailing_list['list_name']
        res[list_name] = mailing_list
    return res

def categorize_data(mailing_lists: list[dict[str:str]]) -> defaultdict[str:defaultdict[str:list[str]]]:
    """
    Categorize each mailing list into its respective selection for each option.

    Args:
        mailing_lists (list[dict[str:str]]): A list of mailing list entries represented as dictionaries. 

    Returns:
        res (defaultdict[str:defaultdict[str:list(str)]]): Categorize the different configurations and index each mailing list into their respective configuration
    """

    if mailing_lists is None:
        raise ValueError("mailing_lists cannot be None")

    res = defaultdict(lambda: defaultdict(list))
    for mailing_list in mailing_lists:
        for option, selection in mailing_list.items():
            if option == 'list_name': continue
            res[option][selection].append(mailing_list['list_name'])
    return res

def parse_args():
    parser = argparse.ArgumentParser(description="Get symmpa_session")
    parser.add_argument("-s", "--sympa_session", type=str, default='', help="sympa_session cookie for logged in session. Outputs a file with list names and their configurations")
    parser.add_argument("-c", "--console", action='store_true', help="Dump list metatdata to console")
    parser.add_argument("-o", "--option", choices=["list", "categorize", "match"], required=True)
    args = parser.parse_args()
    return args

def main():
    # Get the user arguments
    args = parse_args()
    
    # Start the selenium session
    driver = connect_with_session(args.sympa_session)

    # Get all lists
    list_names = get_list_names(driver)

    # Get lists' metadata
    mailing_lists = list()
    for list_name in list_names:
        mailing_lists.append(get_list_configuration(driver, list_name))  

    # Ends the selenium session
    driver.quit()

    output = None
    if args.option == 'list':
        output = transform_mailing_lists_to_dict(mailing_lists)
    elif args.option == 'categorize':
        output = categorize_data(mailing_lists)
    elif args.option == 'match':
        output = transform_mailing_lists_to_dict(get_non_use_case_matches(mailing_lists))

    if args.console:
        dump_to_console(output)
    else:
        dump_to_file(output)

if __name__ == '__main__':
    # Loading in Environment variables 
    MAILING_LIST_URL = os.getenv('MAILING_LIST_URL')
    OUTPUT_FILE = os.getenv('OUTPUT_FILE')
    USER_AGENT = os.getenv('USER_AGENT')
    USE_CASE_PATH = os.getenv('USE_CASE_PATH')

    main()
    
    
